/**
 * ЗАМЫКАНИЯ.
 * JavaScript дает множество свобод программисту для написания программы. 
 *      Отсутствие типизации (переменная может быть чем угодно, от числа, до объекта или функции)
 *      Динамические функции (в переменную можно поместить функцию а затем вызвать ее в теле другой функции)
 * Однако, эта свобода влечет за собой правила. Эти правила помогают программистам понимать, в какой момент
 * программы, произойдет то или иное действие, каким образом программа будет решать неоднозначности написания кода.
 * Например: 
 *     * если в функции нет объявления переменной, откуда она получит ее значение.
 *     * какое значение глобальной переменной будет использоваться в функции, если между объявлением функции и ее вызом 
 *          это значение меняется
 * 
 * Эти два вопроса очень взаимосвязанны, поэтому рассмотрим пример, который задаст нам точку отсчета 
 */

let name = 'Вася';

function printName() {
    console.log(name);
}

name = 'Петя';
printName();
/* Какой будет результат? 

Для того чтобы дать ответ, нам нужно познакомится со скрытным механизмом языка который называется
"Лексическое окружение" или LexicalEnvironment. 

LexicalEnvironment - это механизм языка позволяющий функциям программы, блокам кода и самой программе определять значения
переменных и находить их значения, а так же определять взаимосвязь между блоками кода.
Данный механизм является наполовину скрытым от программиста и увидеть его в действие к сожалению не представляется
возможным. 
Разберем что такое LexicalEnvironment
Лексическое окружение состоит из 2 частей:
1. Environment Record - это объект, который хранит в себе переменные и их значение по ходу выполнения программы. 
Если по простому, это некоторый словарь или книга учета, в которую программа или функция(у каждой свое лексическое окружение)
записывает имя переменной и ее значение на текущий момент.
Пример как это выглядит 1.jpg и пример ниже
*/

//  [[Environment Record]] = {}
let variable;
//  [[Environment Record]] = {variable: undefined}
variable = 2;
//  [[Environment Record]] = {variable: 2}
variable = 'b';
//  [[Environment Record]] = {variable: 'b'}

/*
Программа записывает в этот словарик все переменные, которые объявлены на ее уровне, по мере выполнения кода.
Это важно понимать, что именно по мере выполнения(для let и const). Именно поэтому очень важно объявлять переменные, потому что
так виртуальная машина, выполняющая код, сможет отличить объявление переменной от операцией над ней 


Вторым составляющим LexicalEnvironment является:
2. Outer - Указатель на внешнее/родительское LexicalEnvironment, другими словами на Lexical Environment снаружи скобок/функции
Данный указатель позволяет сформировать некий список из словарей, можно сказать набор знаний программы в данный момент времени.
Первый логический вопрос. Если это указатель на родительское Лексическое окружение, то куда он указывает программе?
Тут просто, он никуда не указывает и имеет значение null. Это позволяет определить конец списка, является неким стоп сигналом о том,
что весь список знаний закончился

Прежде чем мы перейдем дальше сделаем промежуточный выводы:
1. Переменная - это не просто какое-то данное, которое программа где-то там хранит. Это полноценное свойство (пара - ключ:значение)
у программы в словарике
2. Работа с переменными фактически становится работой с этим словариком


Function Declaration. 
Мы добрались до функций. Функция, объявляется иначе нежели переменная, как минимум у нее свое особое ключевое слово и скобочки кругленькие
Виртуальная машина(движок) языка при выполнении кода, как упоминалось выше записывает в словарик переменные по ходу выполнения
С Function Declaration все немного подругому. 

Напомню Function Declaration это:
function iamFunction () {

}

Виртуальная машина, прежде чем выполнять какой-либо код, сначала отсматривает его на наличие
глобальных функций типа Function Declaration. То есть он не выполняет код, а просто ищет в нем именно функции
этого типа. Все что он найдет, он запишет в Лексическое окружение того блока кода, где он нашел эти функции.
То есть, если нашел на уровне программы, то в LexicalEnvironment программы, 
Если в какой-то функции или блока кода , то создает эту запись в LexicalEnvironment у этой функции/блока кода.
Поэтому, когда виртуальная машина начнет выполнять код, она уже будет начинать не с пустым словарем, а вписанными
туда функциями
Пример ниже и 2.jpg (в данном случае, мы рассматриваем Lexical Environment только программы (самый верхний уровень))
*/

/*  
[[Environment Record]] = {
    mayBeYes: function (c, d) {
        return c + d;
    } 
}
*/
let a;
/*  
[[Environment Record]] = {
    mayBeYes: function (c, d) {
        return c + d;
    },
    a: undefined
}
*/
a = 5;
/*  
[[Environment Record]] = {
    mayBeYes: function (c, d) {
        return c + d;
    },
    a: 5
}
*/
function mayBeYes(c, d) {
    return c + d
}
/*  
[[Environment Record]] = {
    mayBeYes: function (c, d) {
        return c + d;
    },
    a: 5
}
*/
a = 10;
/*  
[[Environment Record]] = {
    mayBeYes: function (c, d) {
        return c + d;
    },
    a: 10
}
*/
mayBeYes(1, 2);
/*  
[[Environment Record]] = {
    mayBeYes: function (c, d) {
        return c + d;
    },
    a: 10
}
*/






/*
Сделаем промежуточный вывод:
1. Function Declaration - как и обычные переменные попадают в словарик программы/функции/блока кода. В качестве значения в словарике
сохраняется тело функции с ее аргументами
2. Function Declaration - особенные, и они попадают в Enivroment Record раньше всех, это сделано для упрощения работы
с функциями и с целью позволить вызывать функцию в любом месте кода.

Вернемся к примеру сверху
*/
let name = 'Вася';

function printName() {
    console.log(name);
}

name = 'Петя';
printName();

/*
Теперь, имея эти знания посмотрим как программа узнает что печать. Для этого построим LexicalEnvironment для этого кода
P.S. Чтобы хоть как то разделить две LexicalEnvironment, они будут пронумерованны, в реальности они называются одинаково
1 - это лексическое окружение уровня программы
2 - это лексическое окружение уровеня функции
И для понимания, все комменты даются в момент когда программа выполнит то или иное действие
*/

/* 
Начало программы и в ее lexicalEnvironment пока только функция
[[LexicalEnvironment1]] = {
    [[EnvironmentRecord]]: {
       printName: function () {console.log(name);} 
    },
    outer: null
}*/
let name = 'Вася';
/* 
Добавилась новая переменная со значением
[[LexicalEnvironment1]] = {
    [[EnvironmentRecord]]: {
       printName: function () {console.log(name);},
       name: 'Вася' 
    },
    outer: null
}*/

function printName() {
    /* У функции свой LexicalEnvironment, и ее указатель на лексическое окружение родителя указывает именно на программу
    Т.е. туда, где она была объявлена. 
    [[LexicalEnvironment2]] = {
        [[EnvironmentRecord]]: {},
        outer: [[LexicalEnvironment1]] = {
            [[EnvironmentRecord]]: {
                printName: function () {console.log(name);},
                name: 'Петя' 
            },
            outer: null
        }
    }
    Здесь происходит важный момент. У функции нет в словаре пары с ключом name. Так как, она не знает ее значение
    Она решает посмотреть у родителя, есть ли у него такое свойство в Environment Record и если есть взять его значение
    */
    console.log(name);
    /* [[LexicalEnvironment2]] = {
        [[EnvironmentRecord]]: {},
        outer: [[LexicalEnvironment1]] = {
            [[EnvironmentRecord]]: {
                printName: function () {console.log(name);},
                name: 'Петя' 
            },
            outer: null
        }
    }*/
}
//  Объявление функции с ее описанием никак не влияет на lexicalEnvironment1 поэтому изменений в нем нет

name = 'Петя';
/* 
Присвоили переменной name новое значение, записали в словарь
[[LexicalEnvironment1]] = {
    [[EnvironmentRecord]]: {
       printName: function () {console.log(name);},
       name: 'Петя' 
    },
    outer: null
}
Таким образом, перед вызовом функции name - Петя
*/
printName();
/* Конец программы
[[LexicalEnvironment1]] = {
    [[EnvironmentRecord]]: {
       printName: function () {console.log(name);},
       name: 'Петя' 
    },
    outer: null
}*/












/*
Из разобранного выше, становится понятно, что распечается Петя и как функция узнала значение name
Разберем этот же пример, но уже с неоднозначностью для программиста
*/

let name = 'Вася';

function printName(surname) {
    let name = 'Виталя';
    console.log(surname, name);
}

name = 'Петя';
printName('Волков');

/*
Основная проблема, которая появляется, это две переменные name, чье значение брать
*/

/* 
Начало программы и в ее lexicalEnvironment пока только функция
[[LexicalEnvironment1]] = {
    [[EnvironmentRecord]]: {
       printName: function () {console.log(name);} 
    },
    outer: null
}*/
let name = 'Вася';
/* 
Добавилась новая переменная со значением
[[LexicalEnvironment1]] = {
    [[EnvironmentRecord]]: {
       printName: function () {console.log(name);},
       name: 'Вася' 
    },
    outer: null
}*/

function printName(surname) {
    /* У функции свой LexicalEnvironment, и ее указатель на лексическое окружение родителя указывает именно на программу
    Т.е. туда, где она была объявлена. 
    [[LexicalEnvironment2]] = {
        [[EnvironmentRecord]]: {
            surname: 'Волков'
        },
        outer: [[LexicalEnvironment1]] = {
            [[EnvironmentRecord]]: {
                printName: function () {console.log(name);},
                name: 'Петя' 
            },
            outer: null
        }
    }
    */
    let name = 'Виталя';
    /*
    [[LexicalEnvironment2]] = {
        [[EnvironmentRecord]]: {
            surname: 'Волков',
            name: 'Виталя' 
        },
        outer: [[LexicalEnvironment1]] = {
            [[EnvironmentRecord]]: {
                printName: function () {console.log(name);},
                name: 'Петя' 
            },
            outer: null
        }
    }
    Теперь тот самый момент. У нас 2 name какой же отобразить. Виртуальная машина руководствуется правилом,
    значение должно быть наиболее актуальным, а потому ищем в ближайших словарях. Другими словами приоритет всегда отдается
    переменным из внутреннего LexicalEnvironment а уже потом из внешнего. + Если значение будет браться из внешнего, то поиск значения
    будет производится по правилу: 
        "Ищу пока не найду, от родителей к предкам" 
    */
    console.log(surname, name);  //  Волков Виталя
    /* [[LexicalEnvironment2]] = {
        [[EnvironmentRecord]]: {
            surname: 'Волков',
            name: 'Виталя' 
        },
        outer: [[LexicalEnvironment1]] = {
            [[EnvironmentRecord]]: {
                printName: function () {console.log(name);},
                name: 'Петя' 
            },
            outer: null
        }
    }*/
}
//  Объявление функции с ее описанием никак не влияет на lexicalEnvironment1 поэтому изменений в нем нет

name = 'Петя';
/* 
Присвоили переменной name новое значение, записали в словарь
[[LexicalEnvironment1]] = {
    [[EnvironmentRecord]]: {
       printName: function () {console.log(name);},
       name: 'Петя' 
    },
    outer: null
}
Таким образом, перед вызовом функции name - Петя
*/
printName('Волков');
/* Конец программы
[[LexicalEnvironment1]] = {
    [[EnvironmentRecord]]: {
       printName: function () {console.log(name);},
       name: 'Петя' 
    },
    outer: null
}*/

/*
Из рассмотренных примеров становится понятно, что у функций лексичекое окружение ПОЛНОСТЬЮ формируется именно в момент 
вызова функции. То есть, именно вызов функции создает лексическое окружение функции, так как задает ее аргументы и определяет
поведение функции.

Промежуточные выводы:
    1. Во время выполнения кода, у виртуальной машины, которая выполняет работу есть текущий LexicalEnvironment.
    2. Outer - позволяет виртуальной машине узнавать значения тех или иных переменных у родителей. Так как в случае
    если такой переменной у текущего лексического окружения нет, то по указателю она может посмотреть окружение родителей
    3. Внутренее окружение - окружение виртуальной машины в текущий момент времени. То есть, самое первое
    4. Внешнее окружение - это окружение находящиеся за пределеми ТЕКУЩЕГО блока кода/функции но имеющий с ним связь по
    указателям Outer
    5. Функция получает их последнее значение внешних переменных на момент выполнения кода (на момент обращения к внешним 
        переменным)
    6. Если Виртуальная машина не нашла у себя значение переменной, она узнает у родителей или их родителей. 
    Руководствуясь правилом: "Ищу пока не найду, от родителей к предкам"
    7. Если значение не найдено, то либо виртуальная машина запишет создаст эту переменную, либо сообщит ошибкой,
    либо вернет undefined - так как поиск не дал никаких результатов
    8. Между двумя одинаковыми переменными с одинаковыми именами приоритет отдается переменным из внутреннего окружения, а уже потом 
    внешним.
    9. Каждый вызов функции создает новое LexicalEnvironment отличный от другого. 

Тут надо отступить и сказать, что на самом деле не все так просто. Лексическое окружение – это специальный механизм виртуальной машины, которая
выполняет код. Виртуальных машин для выполнения кода много и есть различия в его поведении но неизменно одно:
«Лексическое окружение» – это специальный внутренний объект. 

Да, мы не можем получить его в нашем коде и изменять напрямую, лишь влияем косвенно объявляя переменные и функции. 
Сам движок JavaScript может оптимизировать его, уничтожать неиспользуемые переменные для освобождения памяти и выполнять другие внутренние уловки, 
но видимое поведение объекта должно оставаться таким, как было описано.
Именно из-за этих оптимизаций console.log() для объектов или массивов ведет себя так глупо (печатая массив, при попытке посмотреть элементы
    массива пишет "доступа к переменным нет" или при просмотре вложенного объекта в объект пишет ...) дело в том, что после печати в том виде
    в котором виртуальная машина распечатала данные, она видит, что они не используются дальше в коде и удаляет эту информацию из словаря. 
    Это удаление позволяет избавить словари от нагромаждения устаревшими и не используемыми данными, однако, приводит к таким сложностям.


Вложенные функции
Вложенные функции - это те функции, которые объявлены внутри другой функции. Зачем так делать?
Все просто. Во-первых, это удобно, когда функция разбивается на несколько логических подблоков. И эти
подблоки и есть вложенные функции.
Например:
Мы хотим написать функцию нахождения большего угла в треугольнике по точкам. 
мы разбиваем эту операцию на 2 действия
    1. Находим стороны треугольника
    2. На основе сторон треугольника находим наибольший угл треугольника
Во-вторых, для определения некоторых особенных данных, с их особым поведением
и методами поведения/изменения/влияния. Такой подход используется в функциях-конструкторах
Например:
*/
function Cat(name) {

    this.inspectСollar = function () {
        return name;
    }

    return this;
}

let kitty = new Cat('Нафаня');
console.log(kitty.inspectСollar());

/*
Рассмотрим еще один пример для изучения замыканий. 
Напишем функцию-конструктор Таймера
*/

function Timer() {
    let _time = 0;

    return function () {
        let prev = _time;
        _time = _time + 1;
        return prev;
    }
}

//  Создадим два таймера
let timer1 = new Timer();
let timer2 = new Timer();

console.log(timer1());      //  Сначала будет 0
console.log(timer1());      //  потом 1
console.log(timer2());      //  А тут ....


/*
Почему же так произошло. Все просто.
1. Виртуальная машина должна выполнить операцию _time++, Первое что она делает смотрит в свой словарь есть ли 
в нем данная переменная
На данный момент Environment Record выглядит так - {}. Короче говоря, он пустой.
2. Поняв, что в Лексическом окружении текущей функции ничего нет, она обращается к родительской области (рисунок 3.jpg (2))
Обращение происходит с помощью Outer
3. Открыв словарь родительской области Виртуальная машина замечает нужный ей _time, который равен 0 на данный момент.
4. Найдя нужные данные и где они хранятся вирутальная машина возвращает значение и меняет его на 1

Остался вопрос почему там 0, а не 2. Все дело в том что как сказано выше каждый вызов функции создает новое лексическое окружение
указывающее на родителя. Для вложенной функции, родитель - это простая функция (в данном случае Timer). Но так как это 
функция, то LexicalEnvironment этой функции определяется ее вызовом. Следовательно, для каждой вложенной функции
родительское Лексическое окружение будет разным, потому что они вызывались два раза, независимо друг от друга. 
Ранее, упоминалось, что виртуальная машина перед выполнением кода, ищет Function Declaration в коде. Теперь, зная 
механизм работы с внутренними функциями, пришло время залезть поглубже под капот нашей машины и узнать, как она
работает с внутренними функциями. Тут нашему взору стает еще один скрытая часть механизма - Environment. 
Когда виртуальная машина находит функцию (не важно Function Declaration или Function Exression), 
она на этих фунциях оставляет некоторую заметку Environment - чтобы помнить, где она нашла эту функцию и какое
Лексическое окружение по отношению к ней считать внешним. 
Когда виртуальная машина встречает вызов такой функции, она должна создать для данного вызова новый словарик,
Где Environment Record - это аргументы функции и Function Declaration внутри, а outer указывает на тот самый Environment


В этом примере есть и 2-ая проблема/особенность(кто как это оценивает) использования вложенных функций.
И так постановка вопроса: Могу ли не находясь в родительской функции, а лишь извне обнулить счетчик, иными словами
    Можно ли используя код, который не относится к функции Timer сбросить _time в 0


Ответ: нет, нельзя. Потому что _time - локальная переменная для кода за пределами данной функции. Другими словами,
никто кроме функции Timer и ее внутренних функций повлиять на _time не может

И так еще выводы:
    1. У каждого вызова функции свой LexicalEnvironment для функции и они независимы друг от друга.
    2. Изменять/Влиять на переменные объявленные внутри функции можно лишь внутри этой функции или с помощью 
    внутренних функций.
    3. Виртуальная машина, для всех фунций оставляет метки, где их можно найти, данная метка называется 
    Environment и не зависит от вызова функции и служит информаций для определения родительского Лексического окружения.

Поскольку у нас уже 4 термина, рассмотрим их поведение на простеньком примере
*/

// (globalEnvironment) [[LexicalEnvironment]]: 
//      [[Environment Record]] = {foo: function foo(){...}, bar: function bar(){...}}
//      [[Outer]]: null — нет родительского окружения
let x = 10;
// (globalEnvironment) [[LexicalEnvironment]]: 
//      [[Environment Record]] = {x: 10, foo: function foo(){...}, bar: function bar(){...}}
//      [[Outer]]: null — нет родительского окружения

function foo() {   //  Метка [[Environment]] = globalEnvironment
    // (fooEnvironment) [[LexicalEnvironment]]: 
    //     [[EnvironmentRecord]] = {}
    //     [[Outer]]: globalEnvironment — глобальное окружение
    let y = 20;
    // (fooEnvironment) [[LexicalEnvironment]]: 
    //     [[EnvironmentRecord]] = {y: 20}
    //     [[Outer]]: globalEnvironment — глобальное окружение


}

function bar() {    //  Метка [[Environment]] = globalEnvironment
    // (barEnvironment) [[LexicalEnvironment]]:
    //     [[EnvironmentRecord]] = {}
    //     [[Outer]]: globalEnvironment — глобальное окружение

    let z = 30;
    // (barEnvironment) [[LexicalEnvironment]]:
    //     [[EnvironmentRecord]] = {z: 30}
    //     [[Outer]]: globalEnvironment — глобальное окружение
}
foo();
bar();
// <--- Лексические окружения рассматриваются из этой точки, то есть после выполнения всех функций


/*
На собеседовании часто спрашивают, что такое "замыкания", это вообще один из первых вопросов Junior разработчику.
Почему? Потому что, как оказалось не знание данного определения - показывает, что вы вообще не очень то хорошо
понимаете как работает виртуальная машина. 
Дадим общее определение:
"Замыкание – это функция, которая запоминает свои внешние переменные и может получить к ним доступ."
Однако, это общее определение, дадим более полное для JavaScript
"Замыкание – это функция, которая запоминает свои внешние переменные и может получить к ним доступ.
В языке JavaScript все функции являются замыканиями,это достижимо за счет LexicalEnvironment и Environment"

Данное определение считает наиболее полным, после такого определения на собеседовании могут попросить показать пример
работы и для объяснения подойдет любой пример из урока.

Закончив с функциями перейдем к тому, о чем мы говорили, но не удиляли внимание. В тексте выше, часто упоминалось 
следующее
"LexicalEnvironment - это механизм языка позволяющий функциям программы, блокам кода и самой программе" 
и
"1. Function Declaration - как и обычные переменные попадают в словарик программы/функции/блока кода."

Мы говорили о программе, о функциях, пришло время блоков кода.
И так блок кода это код заключенный в фигурные скобки {}.
Виртуальная машина применяет механизм LexicalEnviroment и для блоков кода
Рассмотрим пример:
*/

let man = 'Миша';
// (globalEnvironment) [[LexicalEnvironment]]:
    //     [[EnvironmentRecord]] = {man: 'Миша'}
    //     [[Outer]]: null 
if (man == 'Миша') {
    // (subEnvironment) [[LexicalEnvironment]]:
    //     [[EnvironmentRecord]] = {}
    //     [[Outer]]: globalEnvironment
    let woman = 'Таня';
    // (subEnvironment) [[LexicalEnvironment]]:
    //     [[EnvironmentRecord]] = {woman: 'Таня'}
    //     [[Outer]]: globalEnvironment
    console.log(man, woman);    //  ...
}
// (globalEnvironment) [[LexicalEnvironment]]:
    //     [[EnvironmentRecord]] = {man: 'Миша'}
    //     [[Outer]]: null 
console.log(woman); //  undefined - Ведь в текущем словере нет данных о woman, а словарь subEnvironment уже не существует

/*
Из примера видно, что у блока кода с оператором if свое Лексическое окружение
Для циклов for и while тоже создается свое собственное Лексическое окружение. Но тут есть особенность.
Создается собственное Лексическое окружение ДЛЯ КАЖДОГО цикла for и while.
Пример
*/

// (globalEnvironment) [[LexicalEnvironment]]:
    //     [[EnvironmentRecord]] = {}
    //     [[Outer]]: null 
for (let i = 0; i < 10; i++) {
    // (subEnvironment${i}) [[LexicalEnvironment]]:
    //     [[EnvironmentRecord]] = {i: 0} или {i: 1} или {i: 2} или {i: 3} или ... и так для каждого цикла
    //     [[Outer]]: globalEnvironment
    console.log(i);
}
/*
Можно заметить, что хоть и переменная i визуально объявлена запределами {}, однако она считается частью этого блока
Поэтому, при попытке запросить i за пределами for вызовет у виртуальной машины либо ошибку, либо она скажет что не знает что это.
До этого мы рассмотрели действие блоков кода с различными операторами (условия и цикла). Однако, такое поведение сохраняется и без
использования операторов. 
Пример:
*/

// (globalEnvironment) [[LexicalEnvironment]]:
    //     [[EnvironmentRecord]] = {}
    //     [[Outer]]: null 
let a = 2;
// (globalEnvironment) [[LexicalEnvironment]]:
    //     [[EnvironmentRecord]] = {a: 2}
    //     [[Outer]]: null 
{
    // (subEnvironment) [[LexicalEnvironment]]:
    //     [[EnvironmentRecord]] = {}
    //     [[Outer]]: globalEnvironment
    let a = 3;
    // (subEnvironment) [[LexicalEnvironment]]:
    //     [[EnvironmentRecord]] = {a : 3}
    //     [[Outer]]: globalEnvironment
    console.log(a); // 3, а не 2
}
/*
Зачем нужны такие блоки? Для изоляции переменных и функций друг от друга внутри одного файла.
Например, в начале файла мы описываем функции для работы с пользователями, а затем описываем функции для работы с 
Геоданными. Так как обе эти сущности не связанны между собой, их изолируют друг от друга.
Это дает разграничение в работе с даннами, а виртуальной машине вносит однозначность для работы с этими
данными.


Последний рубеж. Сборщик мусора

И так мы знаем что виртуальная машина помимо тех данных которые фигурируют в нашем коде хранит множество служебной
информации(Эти данные ей нужны для работы, потому она никому и не показывает их). Однако, если каждый блок кода/
функция заставляют виртуальную машину создавать лексическое окружение, то рано или поздно это приведет к тому, 
что вирутальной машине придется держать в памяти ОГРОМНЕЕШЕ количество служебных данных, которые она каждый раз
должна пересматривать чтобы дать ответ, какое значение имеет воооооооон та переменная. Поэтому у виртуальной машины
есть такой механизм "сборщик мусора" (Ближайшая ассоциация дворник).
Во время работы виртуальная машина запоминает переменные и их значение и записывает их в словарь.
Обычно после завершения блока кода или функции виртуальная машина зовет дворника, чтобы он убрал все то, что уже не актуально.
А именно локальные переменные и LexicalEnvironment, так как блок уже закончился.
Однако, не все так просто. Дворник, не может удалить то, что в дальнейшем как либо используется.
К примеру, если бы дворник удалял все данные, о том что творилось внутри функции, то не было бы функций конструкторов
или внутренние функции просто бы теряли свои данные. Поэтому, Дворник удаляет только те данные, которые далее нигде не используются.
Опеределяет он это с помощью просмотра связей между LexicalEnviroment всей виртуальной машины. Он пересматривает абсолютно все
такие объекты и устанавливает связи. 
Если у какой то переменной или функции связей нет, то он ее удаляет. 
Если связь(ссылка) осталась, то дворник принимает решение не удалять, пока связи не пропадут

Простыми словами LexicalEnviroment удаляется дворником, когда либо он становится не доступным, либо на него
больше никто не ссылается(переменная или внутреняя функция) 
*/
function Timer() {
    let _time = 0;

    return function () {
        let prev = _time;
        _time = _time + 1;
        return prev;
    }
}

/*
В текущих реалях, у нас не дворник, а робот пылесос. Он способен проанализировать код перед запуском и сделать вывод, когда
та или иная переменная/функция/блок кода станет недоступным, и его LexicalEnvironment можно будет удалить. Помимо этого, 
современный сборщик мусора, позволяет не формировать LexicalEnvironment для тех блоков кода/функций которые не достижимы 
(например находятся после return). А не используемые переменные в текущем контексте даже не заносятся виртуальной машиной в 
LexicalEnvironment
*/