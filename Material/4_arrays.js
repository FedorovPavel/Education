//  Массивы
//  Массивы - это упорядоченая последовательность некоторого набора данных.
//  Массивы имеют несколько имен в зависимости от своей конфигурации:
//      1. Массив или вектор - обычный знакомый массив
//      2. Матрица - массив массивов
//      3. N-мерная матрица - n-вложенный массив массивов
//  Например

//  Объявление и инициализация переменной array1 со значением массив
let array1 = [];

//  Объявление и инициализация переменной array2 со значением вектор
let array2 = [];

//  Объявление и инициализация переменной matrix со значением матрица
let matrix = [[], []];

matrix = [
    [0, 1],
    [2, 3]
];

//  Объявление и инициализация переменной matrix со значением 3-x мерная матрица
let matrix = [
    [
        [1, 3, 5],
        [2, 4, 6]
    ], [
        [8, -1, 4],
        [-9, 6, -2]
    ]
];
//  Очень редко, массив еще называют ЛИСТОМ, это не является ошибкой, однако
//  создает двойственное восприятие о чем идет речь. Потому что ЛИСТ - это некоторая
//  сущность, которая может быть выполнена в различных формах( с помощью массивов или
//  с помощью объектов). Поэтому стараемся избегать эту формулировку при общении,
//  однако, важно все-таки понимать что имел в виду наш собеседник.

//  Каждый элемент массива, называется "элементом" и обычно указывается его индекс
//  В основном, массивы имеют большую распространненость, потому что является наиболее
//  простой и удобной структурую для хранения упорядоченных не связанных между собой данных.


//  Особенности при объявлении массивов
//  1. Массив ведет себя как Объект, потому что массив - это частный случай объекта

//  2. Неочевидные моменты работы с массивами.
//  Пример разреженный вектор (приминим к матрице)
let sparceMatrix = [];

sparceMatrix[0] = 1;
sparceMatrix[1000] = 1000;

sparceMatrix;   //  [1, undefined, undefined, ..., undefined, undefined, 1000];
                //   0      1           2             998        999     1000   

//  При этом, массив будет иметь длинну равную 1001


//  Дополнительные термины.
//  Данные термины в основном применимы больше не к массиву, а к способу взаимодействия с ним.
//  То есть под этими терминами понимается именно СТРУКТУРА (для) или СПОСОБ взаимодействия, а не конкретную реализацию(тип)

//  1. Стек(Stack) - наиболее распространненый тип. Стек - это способ взаимодействия с упорядоченной
//  последовательностью данных, в котором добавление в последовательность происходит в конец, а получение(удаление)
//  элементов из последовательности из конца. Такое взаимодействие еще можно назвать LIFO (last-in first-out).
//  При этом, накладывается ограничение, что просмотр других элементов
//  помимо последнего (без его удаления из последовательности) невозможно. Но мы всегда знаем сколько элементов в
//  структуре. 
//  Наиболее схожей аналогией является - ящик с одеждой. Мы укладываем сначала располагаем на дне ящика
//  нашу одежду. Постепенно, футболки, свитера, накладываются друг на друга и достигают верха ящика.
//  При этом мы видим только самый верхний элемент одежды, те что на дне нам не видны. 
//  Чтобы получить те, что расположены на дне ящика, нам придется убрать одежду сверху и переложить в другой ящик 
//  или условно выбросить.
//  Когда применяется? Когда у нас есть задача с похожей функциональностью. Т.е. что то в программе, напоминает этот ящик

//  2. Список/Лист/Очередь(List/Queue) - это способ взаимодействия с упорядоченной последовательностью данных,
//  в котором добавление происходит в конец, а получение(удаление) с начала. Такое взаимодействие называется
//  FIFO. Ограничения стека все еще сохраняются. Наиболее схожей аналогией в реальном мире является, очередь
//  в кассу магазина. То есть сначала приходит человек и становится первым и допустим касса еще не работает. 
//  За ним становится следующий и следующий. Причем, никто из покупателей не хочет или не может из нее выйти, не пройдя через кассу
//  Когда касса работает, то она обрабатывает клиетов в порядке следования. Обычно начало списка или очереди
//  называют ГОЛОВОЙ списка, а конец - ХВОСТОМ(эти термины обычно фигурируют именно в рамках данной терминологии)
//  Когда применяется? Чаще всего тип взаимодействия применяется в основном к очередям - заявок. 
//  Как и со стеком, данный тип применяется исходя из схожести с поведением аналогии. 
//  Пример: список отправки писем пользователям нашего сайта. Наш список будет сформирован из пользователей и последовательно
//  каждому будет отправлять письмо

//  3. Дек(Deque) - это способ взаимодействия с упорядоченной последовательностью данных, в котором добавление новых 
//  элементов происходит и в КОНЕЦ и в НАЧАЛО, получение(удаление) и из КОНЦА и из НАЧАЛА. Дек - это слияние Стека и очереди.
//  Дек - очень тяжело заметить с точки зрения его применения. Так как, ограничения накладываемые им почти несущественны
//  и только усложняют разработку по отношению к обычному массиву. НО, это не значит что он не применим, просто 
//  применяется гораздо реже. Аналогия для дека - вагоны на перегонном пункте. у нас есть некоторый состав вагонов,
//  мы можем добавлять новые вагоны и в начало и в конец состава, но не в середину, отсоединять вагоны можем точно также
//  либо с конца, либо с начала. 


//  Методы массива
//  Большинство методов работы с массивом очень схожи между собой. 
//  Методы: map, filter, sort, find, findIndex, reverse - являются облегчающими.
//  Это значит что можно обойтись и без них, однако на произведение этих действий
//  потребуется больше времени

//  Если посмотреть на эти методы, то большинство из этих методов имеют одну общую структуру
//  А именно им нужно передать в качестве аргумента Функцию
//  Пример
let list = [1,2,3,4];

list.map(function (item, index, array) {
    return Math.pow(item,2);
});

list.filter(function (item, index, array) {
    return item % 2;
});

//  Аргументы у самих функций разные, разберем типовые шаблоны
let pattern1 = function (item, index, array) {

};
/*
    Этот паттер применим для map, filter, find, findIndex.
    Данные методы вызывают функцию pattern1 для КАЖДОГО элемента
    массива последовательно. То есть функция pattern1 будет вызвана N раз, 
    где N - количество элементов в массиве 

    Разберем аргументы функции. Все они являются опциональными, но без них
    смысла применения метода - нет.
    item -  текущий элемент массива. Именно в данный аргумент будут последовательно
    устанавливаться элементы массива. Данный аргумент практически всегда участвует в функции. 
    Он нужен именно для обработки данных элемента массива.

    
    index - индекс текущего элемента в массиве. В данный аргумент будет устанавливаться 
    индекс в массиве текущего item в массиве. Для чего он нужен и когда его использовать?
    Используется индекс, для определения положения item в массиве и введение дополнительных
    ограничений на поиск/преобразование/отбор. Например, если мы ищем элемент, начиная со 2 элемента или хотим
    исключить последние 2 элемента. Другой причиной использования индекса является установка взаимосвязей 
    с другими элементами массива. То есть когда на результат операции, влияет соседний элемент или элемент стоящий в любом
    месте массива.


    array - исходный массив. В данный аргумент устанавливается исходный (не модифицированный) массив. 
    Для чего он нужен? Используется в паре с index для 2 варианта использования index. 
    Другими словами, чтобы получить данные соседей текущего элемента, которые влияют на операцию    
*/

let pattern2 = function(next, cur) {

}
/*
    Этот паттер применим для sort.
    Данный методы вызывает функцию pattern2 для КАЖДОГО элемента
    массива последовательно. То есть функция pattern2 будет вызвана N раз, 
    где N - количество элементов в массиве. 

    Разберем аргументы функции. Все они являются опциональными, но без них
    смысла применения метода - нет.

    next - следующий от текущего элемента элемент. Именно в данный аргумент будут последовательно
    устанавливаться элементы массива с индексом равным индекс текущего элемента + 1. 
        
    cur - текущий элемент. Именно в данный аргумент будут последовательно
    устанавливаться текущий элемент .
    
    Теперь важное для sort
    в данной функции необходимо вернуть 1 из 3 значений, чтобы метод sort понял в каком порядке
    относительно друг друга расположить next и cur (кого сначала, кого в конец(внутри пары))

    Если мы хотим, чтобы cur шел раньше чем next в массиве, то необходимо вернуть 1
    Если мы хотим, чтобы cur шел после next в массиве(индекс cur > index next), то необходимо вернуть -1
    Если мы не хотим менять расположение или данные элементы между собой равны, вернуть 0.
*/
